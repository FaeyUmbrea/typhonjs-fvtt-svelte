import { SvelteComponent, init, safe_not_equal, create_component, mount_component, noop, transition_in, transition_out, destroy_component, flush, append_styles, empty, insert, group_outros, check_outros, detach, element, attr, get_spread_update, get_spread_object, destroy_each, assign, space, append, binding_callbacks, create_slot, update_slot_base, get_all_dirty_from_scope, get_slot_changes, text, set_data, listen, null_to_empty, set_style, add_render_callback, create_bidirectional_transition, globals, current_component } from 'svelte/internal';
import { getContext, setContext, createEventDispatcher } from 'svelte';
import TJSContainer$1, { TJSApplicationHeader as TJSApplicationHeader$1, TJSContainer as TJSContainer$2, TJSHeaderButton as TJSHeaderButton$1 } from '@typhonjs-fvtt/svelte/component';
import { localize } from '@typhonjs-fvtt/svelte/helper';
import { slideFade } from '@typhonjs-fvtt/svelte/transition';
import { outroAndDestroy } from '@typhonjs-fvtt/svelte/util';

/* src\modules\component\TJSComponentShell.svelte generated by Svelte v3.44.1 */

function create_fragment$6(ctx) {
	let tjscontainer;
	let current;

	tjscontainer = new TJSContainer$1({
			props: {
				children: /*children*/ ctx[0],
				warn: true
			}
		});

	return {
		c() {
			create_component(tjscontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tjscontainer, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(tjscontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tjscontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tjscontainer, detaching);
		}
	};
}

function instance$6($$self) {
	const context = getContext('external');
	const children = typeof context === 'object' ? context.children : void 0;
	return [children];
}

class TJSComponentShell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
	}
}

/* src\modules\component\TJSContainer.svelte generated by Svelte v3.44.1 */

function add_css$2(target) {
	append_styles(target, "svelte-1s361pr", "p.svelte-1s361pr{color:red;font-size:18px}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (12:15) 
function create_if_block_1(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Container warning: No children.";
			attr(p, "class", "svelte-1s361pr");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (8:0) {#if Array.isArray(children)}
function create_if_block$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*children*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) {
				each_value = /*children*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (9:4) {#each children as child}
function create_each_block$2(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*child*/ ctx[2].props];
	var switch_value = /*child*/ ctx[2].class;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty & /*children*/ 2)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*child*/ ctx[2].props)])
			: {};

			if (switch_value !== (switch_value = /*child*/ ctx[2].class)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment$5(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_if_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (show_if == null || dirty & /*children*/ 2) show_if = !!Array.isArray(/*children*/ ctx[1]);
		if (show_if) return 0;
		if (/*warn*/ ctx[0]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { warn = false } = $$props;
	let { children = void 0 } = $$props;

	$$self.$$set = $$props => {
		if ('warn' in $$props) $$invalidate(0, warn = $$props.warn);
		if ('children' in $$props) $$invalidate(1, children = $$props.children);
	};

	return [warn, children];
}

class TJSContainer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { warn: 0, children: 1 }, add_css$2);
	}

	get warn() {
		return this.$$.ctx[0];
	}

	set warn(warn) {
		this.$$set({ warn });
		flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		flush();
	}
}

/* src\modules\component\application\ApplicationShell.svelte generated by Svelte v3.44.1 */

function create_else_block$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (30:8) {#if Array.isArray(children)}
function create_if_block$1(ctx) {
	let tjscontainer;
	let current;
	tjscontainer = new TJSContainer$2({ props: { children: /*children*/ ctx[5] } });

	return {
		c() {
			create_component(tjscontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tjscontainer, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(tjscontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tjscontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tjscontainer, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let div;
	let tjsapplicationheader;
	let t;
	let section;
	let current_block_type_index;
	let if_block;
	let div_style_value;
	let current;

	tjsapplicationheader = new TJSApplicationHeader$1({
			props: {
				title: /*appTitle*/ ctx[1],
				headerButtons: /*foundryApp*/ ctx[4]._getHeaderButtons()
			}
		});

	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (Array.isArray(/*children*/ ctx[5])) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			create_component(tjsapplicationheader.$$.fragment);
			t = space();
			section = element("section");
			if_block.c();
			attr(section, "class", "window-content");
			attr(div, "id", /*foundryApp*/ ctx[4].id);
			attr(div, "class", "app window-app " + /*foundryApp*/ ctx[4].options.classes.join(' '));
			attr(div, "data-appid", /*foundryApp*/ ctx[4].appId);

			attr(div, "style", div_style_value = Number.isInteger(/*zIndex*/ ctx[0])
			? `z-index: ${/*zIndex*/ ctx[0]}`
			: '');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(tjsapplicationheader, div, null);
			append(div, t);
			append(div, section);
			if_blocks[current_block_type_index].m(section, null);
			/*section_binding*/ ctx[9](section);
			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p(ctx, [dirty]) {
			const tjsapplicationheader_changes = {};
			if (dirty & /*appTitle*/ 2) tjsapplicationheader_changes.title = /*appTitle*/ ctx[1];
			tjsapplicationheader.$set(tjsapplicationheader_changes);
			if_block.p(ctx, dirty);

			if (!current || dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = Number.isInteger(/*zIndex*/ ctx[0])
			? `z-index: ${/*zIndex*/ ctx[0]}`
			: '')) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(tjsapplicationheader.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(tjsapplicationheader.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(tjsapplicationheader);
			if_blocks[current_block_type_index].d();
			/*section_binding*/ ctx[9](null);
			/*div_binding*/ ctx[10](null);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title = void 0 } = $$props;
	let { zIndex = void 0 } = $$props;
	let appTitle;
	let content, root;
	const context = getContext('external');
	const foundryApp = context.foundryApp;
	const children = typeof context === 'object' ? context.children : void 0;

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			content = $$value;
			$$invalidate(2, content);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			root = $$value;
			$$invalidate(3, root);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(6, title = $$props.title);
		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title*/ 64) {
			$$invalidate(1, appTitle = typeof title === 'string' ? title : foundryApp.title);
		}
	};

	return [
		zIndex,
		appTitle,
		content,
		root,
		foundryApp,
		children,
		title,
		$$scope,
		slots,
		section_binding,
		div_binding
	];
}

class ApplicationShell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { title: 6, zIndex: 0 });
	}

	get title() {
		return this.$$.ctx[6];
	}

	set title(title) {
		this.$$set({ title });
		flush();
	}

	get zIndex() {
		return this.$$.ctx[0];
	}

	set zIndex(zIndex) {
		this.$$set({ zIndex });
		flush();
	}
}

/* src\modules\component\application\TJSApplicationHeader.svelte generated by Svelte v3.44.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (12:4) {#each headerButtons as button}
function create_each_block$1(ctx) {
	let tjsheaderbutton;
	let current;
	tjsheaderbutton = new TJSHeaderButton$1({ props: { button: /*button*/ ctx[2] } });

	return {
		c() {
			create_component(tjsheaderbutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tjsheaderbutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tjsheaderbutton_changes = {};
			if (dirty & /*headerButtons*/ 2) tjsheaderbutton_changes.button = /*button*/ ctx[2];
			tjsheaderbutton.$set(tjsheaderbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tjsheaderbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tjsheaderbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tjsheaderbutton, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let header;
	let h4;
	let t0;
	let t1;
	let current;
	let each_value = /*headerButtons*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			header = element("header");
			h4 = element("h4");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h4, "class", "window-title");
			attr(header, "class", "window-header flexrow");
		},
		m(target, anchor) {
			insert(target, header, anchor);
			append(header, h4);
			append(h4, t0);
			append(header, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(header, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);

			if (dirty & /*headerButtons*/ 2) {
				each_value = /*headerButtons*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(header, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(header);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { title = '' } = $$props;
	let { headerButtons = [] } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('headerButtons' in $$props) $$invalidate(1, headerButtons = $$props.headerButtons);
	};

	return [title, headerButtons];
}

class TJSApplicationHeader extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { title: 0, headerButtons: 1 });
	}

	get title() {
		return this.$$.ctx[0];
	}

	set title(title) {
		this.$$set({ title });
		flush();
	}

	get headerButtons() {
		return this.$$.ctx[1];
	}

	set headerButtons(headerButtons) {
		this.$$set({ headerButtons });
		flush();
	}
}

/* src\modules\component\application\TJSApplicationShell.svelte generated by Svelte v3.44.1 */

function add_css$1(target) {
	append_styles(target, "svelte-1x0d3b3", ".typhonjs-app{max-height:100%;background:url(/ui/denim075.png) repeat;border-radius:5px;box-shadow:0 0 20px #000;margin:3px 0;color:#f0f0e0;position:absolute}.typhonjs-window-app{display:flex;flex-direction:column;flex-wrap:nowrap;justify-content:flex-start;padding:0;z-index:99}.typhonjs-window-app .window-content{display:flex;flex-direction:column;flex-wrap:nowrap;justify-content:flex-start;padding:8px;color:#191813;overflow-y:auto;overflow-x:hidden}.typhonjs-window-app .window-header{flex:0 0 30px;overflow:hidden;padding:0 8px;line-height:30px;border-bottom:1px solid #000;pointer-events:auto}.typhonjs-window-app .window-header a{flex:none;margin:0 0 0 8px}.typhonjs-window-app .window-header h4{font-family:Signika, sans-serif}.typhonjs-window-app .window-header i[class^=fa]{margin-right:3px}.typhonjs-window-app .window-header .window-title{margin:0;word-break:break-all}.typhonjs-window-app .window-resizable-handle{width:20px;height:20px;position:absolute;bottom:-1px;right:0;background:#444;padding:2px;border:1px solid #111;border-radius:4px 0 0 0}.typhonjs-window-app .window-resizable-handle i.fas{transform:rotate(45deg)}.typhonjs-window-app.minimized .window-header{border:1px solid #000}.typhonjs-window-app.minimized .window-resizable-handle{display:none}");
}

// (35:8) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (33:8) {#if Array.isArray(children)}
function create_if_block(ctx) {
	let tjscontainer;
	let current;
	tjscontainer = new TJSContainer$2({ props: { children: /*children*/ ctx[5] } });

	return {
		c() {
			create_component(tjscontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tjscontainer, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(tjscontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tjscontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tjscontainer, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let tjsapplicationheader;
	let t;
	let section;
	let current_block_type_index;
	let if_block;
	let div_style_value;
	let current;

	tjsapplicationheader = new TJSApplicationHeader$1({
			props: {
				title: /*appTitle*/ ctx[1],
				headerButtons: /*foundryApp*/ ctx[4]._getHeaderButtons()
			}
		});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (Array.isArray(/*children*/ ctx[5])) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			create_component(tjsapplicationheader.$$.fragment);
			t = space();
			section = element("section");
			if_block.c();
			attr(section, "class", "window-content");
			attr(div, "id", /*foundryApp*/ ctx[4].id);
			attr(div, "class", "typhonjs-app typhonjs-window-app " + /*foundryApp*/ ctx[4].options.classes.join(' '));
			attr(div, "data-appid", /*foundryApp*/ ctx[4].appId);

			attr(div, "style", div_style_value = Number.isInteger(/*zIndex*/ ctx[0])
			? `z-index: ${/*zIndex*/ ctx[0]}`
			: '');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(tjsapplicationheader, div, null);
			append(div, t);
			append(div, section);
			if_blocks[current_block_type_index].m(section, null);
			/*section_binding*/ ctx[9](section);
			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p(ctx, [dirty]) {
			const tjsapplicationheader_changes = {};
			if (dirty & /*appTitle*/ 2) tjsapplicationheader_changes.title = /*appTitle*/ ctx[1];
			tjsapplicationheader.$set(tjsapplicationheader_changes);
			if_block.p(ctx, dirty);

			if (!current || dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = Number.isInteger(/*zIndex*/ ctx[0])
			? `z-index: ${/*zIndex*/ ctx[0]}`
			: '')) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(tjsapplicationheader.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(tjsapplicationheader.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(tjsapplicationheader);
			if_blocks[current_block_type_index].d();
			/*section_binding*/ ctx[9](null);
			/*div_binding*/ ctx[10](null);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title = void 0 } = $$props;
	let { zIndex = void 0 } = $$props;
	let appTitle;
	let content, root;
	setContext('getElementContent', () => content);
	setContext('getElementRoot', () => root);
	const context = getContext('external');
	const foundryApp = context.foundryApp;
	const children = typeof context === 'object' ? context.children : void 0;

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			content = $$value;
			$$invalidate(2, content);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			root = $$value;
			$$invalidate(3, root);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(6, title = $$props.title);
		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title*/ 64) {
			$$invalidate(1, appTitle = typeof title === 'string' ? title : foundryApp.title);
		}
	};

	return [
		zIndex,
		appTitle,
		content,
		root,
		foundryApp,
		children,
		title,
		$$scope,
		slots,
		section_binding,
		div_binding
	];
}

class TJSApplicationShell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { title: 6, zIndex: 0 }, add_css$1);
	}

	get title() {
		return this.$$.ctx[6];
	}

	set title(title) {
		this.$$set({ title });
		flush();
	}

	get zIndex() {
		return this.$$.ctx[0];
	}

	set zIndex(zIndex) {
		this.$$set({ zIndex });
		flush();
	}
}

/* src\modules\component\application\TJSHeaderButton.svelte generated by Svelte v3.44.1 */

function create_fragment$1(ctx) {
	let a;
	let i;
	let i_class_value;
	let i_title_value;
	let t_value = localize(/*button*/ ctx[0].label) + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			a = element("a");
			i = element("i");
			t = text(t_value);
			attr(i, "class", i_class_value = /*button*/ ctx[0].icon);
			attr(i, "title", i_title_value = localize(/*button*/ ctx[0].title));
			attr(a, "class", "header-button");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, i);
			append(a, t);

			if (!mounted) {
				dispose = listen(a, "click", /*onClick*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*button*/ 1 && i_class_value !== (i_class_value = /*button*/ ctx[0].icon)) {
				attr(i, "class", i_class_value);
			}

			if (dirty & /*button*/ 1 && i_title_value !== (i_title_value = localize(/*button*/ ctx[0].title))) {
				attr(i, "title", i_title_value);
			}

			if (dirty & /*button*/ 1 && t_value !== (t_value = localize(/*button*/ ctx[0].label) + "")) set_data(t, t_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { button } = $$props;

	function onClick() {
		if (typeof button.onclick === 'function') {
			button.onclick.call(button);
			$$invalidate(0, button);
		}
	}

	$$self.$$set = $$props => {
		if ('button' in $$props) $$invalidate(0, button = $$props.button);
	};

	return [button, onClick];
}

class TJSHeaderButton extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { button: 0 });
	}

	get button() {
		return this.$$.ctx[0];
	}

	set button(button) {
		this.$$set({ button });
		flush();
	}
}

/* src\modules\component\contextmenu\TJSContextMenu.svelte generated by Svelte v3.44.1 */

const { document: document_1 } = globals;

function add_css(target) {
	append_styles(target, "svelte-thdn97", ".tjs-context-menu.svelte-thdn97.svelte-thdn97.svelte-thdn97{position:fixed;width:fit-content;font-size:14px;box-shadow:0 0 10px #000;height:max-content;min-width:150px;max-width:360px;background:#23221d;border:1px solid #000;border-radius:5px;color:#EEE}.tjs-context-menu.svelte-thdn97 ol.tjs-context-items.svelte-thdn97.svelte-thdn97{list-style:none;margin:0;padding:0}.tjs-context-menu.svelte-thdn97 li.tjs-context-item.svelte-thdn97.svelte-thdn97{padding:0 5px;line-height:32px}.tjs-context-menu.svelte-thdn97 li.tjs-context-item.svelte-thdn97.svelte-thdn97:hover{color:#FFF;text-shadow:0 0 4px red}.tjs-context-menu.svelte-thdn97 li.tjs-context-item.svelte-thdn97>i.svelte-thdn97{margin-right:5px}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

// (96:8) {#each items as item}
function create_each_block(ctx) {
	let li;
	let i;
	let i_class_value;
	let t_value = localize(/*item*/ ctx[15].label) + "";
	let t;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[10](/*item*/ ctx[15]);
	}

	return {
		c() {
			li = element("li");
			i = element("i");
			t = text(t_value);
			attr(i, "class", i_class_value = "" + (null_to_empty(/*item*/ ctx[15].icon) + " svelte-thdn97"));
			attr(li, "class", "tjs-context-item svelte-thdn97");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, i);
			append(li, t);

			if (!mounted) {
				dispose = listen(li, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*items*/ 2 && i_class_value !== (i_class_value = "" + (null_to_empty(/*item*/ ctx[15].icon) + " svelte-thdn97"))) {
				attr(i, "class", i_class_value);
			}

			if (dirty & /*items*/ 2 && t_value !== (t_value = localize(/*item*/ ctx[15].label) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let t;
	let nav;
	let ol;
	let nav_transition;
	let current;
	let mounted;
	let dispose;
	let each_value = /*items*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			t = space();
			nav = element("nav");
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ol, "class", "tjs-context-items svelte-thdn97");
			attr(nav, "id", /*id*/ ctx[0]);
			attr(nav, "class", "tjs-context-menu svelte-thdn97");
			set_style(nav, "z-index", /*zIndex*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
			insert(target, nav, anchor);
			append(nav, ol);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			/*nav_binding*/ ctx[11](nav);
			current = true;

			if (!mounted) {
				dispose = listen(document_1.body, "pointerdown", /*onClose*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*onClick, items, localize*/ 34) {
				each_value = /*items*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*id*/ 1) {
				attr(nav, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*zIndex*/ 4) {
				set_style(nav, "z-index", /*zIndex*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!nav_transition) nav_transition = create_bidirectional_transition(nav, /*animate*/ ctx[4], {}, true);
				nav_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!nav_transition) nav_transition = create_bidirectional_transition(nav, /*animate*/ ctx[4], {}, false);
			nav_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t);
			if (detaching) detach(nav);
			destroy_each(each_blocks, detaching);
			/*nav_binding*/ ctx[11](null);
			if (detaching && nav_transition) nav_transition.end();
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { id = '' } = $$props;
	let { x = 0 } = $$props;
	let { y = 0 } = $$props;
	let { items = [] } = $$props;
	let { zIndex = 10000 } = $$props;
	let { transitionOptions = void 0 } = $$props;

	// Bound to the nav element / menu.
	let menuEl;

	// Store this component reference.
	const local = current_component;

	// Dispatches `close` event.
	const dispatch = createEventDispatcher();

	// Stores if this context menu is closed.
	let closed = false;

	/**
 * Provides a custom animate callback allowing inspection of the element to change positioning styles based on the
 * height / width of the element and `document.body`. This allows the context menu to expand up when the menu
 * is outside the height bound of `document.body` and expand to the left if width is greater than `document.body`.
 *
 * @param {HTMLElement} node - nav element.
 *
 * @returns {object} Transition object.
 */
	function animate(node) {
		const expandUp = y + node.clientHeight > document.body.clientHeight;
		const expandLeft = x + node.clientWidth > document.body.clientWidth;
		node.style.top = expandUp ? null : `${y}px`;
		node.style.bottom = expandUp ? `${document.body.clientHeight - y}px` : null;
		node.style.left = expandLeft ? null : `${x}px`;
		node.style.right = expandLeft ? `${document.body.clientWidth - x}px` : null;
		return slideFade(node, transitionOptions);
	}

	/**
 * Invokes a function on click of a menu item then fires the `close` event and automatically runs the outro
 * transition and destroys the component.
 *
 * @param {function} callback - Function to invoke on click.
 */
	function onClick(callback) {
		if (typeof callback === 'function') {
			callback();
		}

		if (!closed) {
			dispatch('close');
			closed = true;
			outroAndDestroy(local);
		}
	}

	/**
 * Determines if a pointer pressed to the document body closes the context menu. If the click occurs outside the
 * context menu then fire the `close` event and run the outro transition then destroy the component.
 *
 * @param {PointerEvent}   event - Pointer event from document body click.
 */
	async function onClose(event) {
		// Early out if the pointer down is inside the menu element.
		if (event.target === menuEl || menuEl.contains(event.target)) {
			return;
		}

		// Early out if the event page X / Y is the same as this context menu.
		if (Math.floor(event.pageX) === x && Math.floor(event.pageY) === y) {
			return;
		}

		if (!closed) {
			dispatch('close');
			closed = true;
			outroAndDestroy(local);
		}
	}

	const click_handler = item => onClick(item.onclick);

	function nav_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			menuEl = $$value;
			$$invalidate(3, menuEl);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('x' in $$props) $$invalidate(7, x = $$props.x);
		if ('y' in $$props) $$invalidate(8, y = $$props.y);
		if ('items' in $$props) $$invalidate(1, items = $$props.items);
		if ('zIndex' in $$props) $$invalidate(2, zIndex = $$props.zIndex);
		if ('transitionOptions' in $$props) $$invalidate(9, transitionOptions = $$props.transitionOptions);
	};

	return [
		id,
		items,
		zIndex,
		menuEl,
		animate,
		onClick,
		onClose,
		x,
		y,
		transitionOptions,
		click_handler,
		nav_binding
	];
}

class TJSContextMenu extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				id: 0,
				x: 7,
				y: 8,
				items: 1,
				zIndex: 2,
				transitionOptions: 9
			},
			add_css
		);
	}
}

export { ApplicationShell, TJSApplicationHeader, TJSApplicationShell, TJSComponentShell, TJSContainer, TJSContextMenu, TJSHeaderButton };
//# sourceMappingURL=component.js.map
