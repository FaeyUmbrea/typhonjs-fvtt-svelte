{"version":3,"file":"index.js","sources":["../../../../typhonjs-svelte/lib/src/store/functions.js","../../../../typhonjs-svelte/lib/src/animate/animateEvents.js","../../../../typhonjs-svelte/lib/src/animate/nextAnimationFrame.js"],"sourcesContent":["/**\r\n * Provides a basic test for a given variable to test if it has the shape of a readable store by having a `subscribe`\r\n * function.\r\n *\r\n * Note: functions are also objects, so test that the variable might be a function w/ a `subscribe` function.\r\n *\r\n * @param {*}  store - variable to test that might be a store.\r\n *\r\n * @returns {boolean} Whether the variable tested has the shape of a store.\r\n */\r\nexport function isReadableStore(store)\r\n{\r\n   if (store === null || store === void 0) { return false; }\r\n\r\n   switch (typeof store)\r\n   {\r\n      case 'function':\r\n      case 'object':\r\n         return typeof store.subscribe === 'function';\r\n   }\r\n\r\n   return false;\r\n}\r\n\r\n/**\r\n * Provides a basic test for a given variable to test if it has the shape of a writable store by having a `subscribe`\r\n * function and an `update` function.\r\n *\r\n * Note: functions are also objects, so test that the variable might be a function w/ a `subscribe` function.\r\n *\r\n * @param {*}  store - variable to test that might be a store.\r\n *\r\n * @returns {boolean} Whether the variable tested has the shape of a store.\r\n */\r\nexport function isUpdatableStore(store)\r\n{\r\n   if (store === null || store === void 0) { return false; }\r\n\r\n   switch (typeof store)\r\n   {\r\n      case 'function':\r\n      case 'object':\r\n         return typeof store.subscribe === 'function' && typeof store.update === 'function';\r\n   }\r\n\r\n   return false;\r\n}\r\n\r\n/**\r\n * Provides a basic test for a given variable to test if it has the shape of a writable store by having a `subscribe`\r\n * `set`, and `update` functions.\r\n *\r\n * Note: functions are also objects, so test that the variable might be a function w/ `subscribe` & `set` functions.\r\n *\r\n * @param {*}  store - variable to test that might be a store.\r\n *\r\n * @returns {boolean} Whether the variable tested has the shape of a store.\r\n */\r\nexport function isWritableStore(store)\r\n{\r\n   if (store === null || store === void 0) { return false; }\r\n\r\n   switch (typeof store)\r\n   {\r\n      case 'function':\r\n      case 'object':\r\n         return typeof store.subscribe === 'function' && typeof store.set === 'function';\r\n   }\r\n\r\n   return false;\r\n}\r\n\r\n/**\r\n * Subscribes to the given store with the update function provided and ignores the first automatic\r\n * update. All future updates are dispatched to the update function.\r\n *\r\n * @param {import('svelte/store').Readable | import('svelte/store').Writable} store -\r\n *  Store to subscribe to...\r\n *\r\n * @param {import('svelte/store').Updater} update - function to receive future updates.\r\n *\r\n * @returns {import('svelte/store').Unsubscriber} Store unsubscribe function.\r\n */\r\nexport function subscribeIgnoreFirst(store, update)\r\n{\r\n   let firedFirst = false;\r\n\r\n   return store.subscribe((value) => {\r\n      if (!firedFirst)\r\n      {\r\n         firedFirst = true;\r\n      }\r\n      else {\r\n         update(value);\r\n      }\r\n   })\r\n}\r\n\r\n/**\r\n * Subscribes to the given store with two update functions provided. The first function is invoked on the initial\r\n * subscription. All future updates are dispatched to the update function.\r\n *\r\n * @param {import('svelte/store').Readable | import('svelte/store').Writable} store -\r\n *  Store to subscribe to...\r\n *\r\n * @param {import('svelte/store').Updater} first - Function to receive first update.\r\n *\r\n * @param {import('svelte/store').Updater} update - Function to receive future updates.\r\n *\r\n * @returns {import('svelte/store').Unsubscriber} Store unsubscribe function.\r\n */\r\nexport function subscribeFirstRest(store, first, update)\r\n{\r\n   let firedFirst = false;\r\n\r\n   return store.subscribe((value) => {\r\n      if (!firedFirst)\r\n      {\r\n         firedFirst = true;\r\n         first(value);\r\n      }\r\n      else {\r\n         update(value);\r\n      }\r\n   })\r\n}\r\n","import { isWritableStore } from '@typhonjs-svelte/lib/store';\r\n\r\n/**\r\n * Svelte doesn't provide any events for the animate directive.\r\n *\r\n * The provided function below wraps a Svelte animate directive function generating bubbling events for start & end of\r\n * animation.\r\n *\r\n * These events are `animate:start` and `animate:end`.\r\n *\r\n * This is useful for instance if you are animating several nodes in a scrollable container where the overflow parameter\r\n * needs to be set to `none` while animating such that the scrollbar is not activated by the animation.\r\n *\r\n * Optionally you may also provide a boolean writable store that will be set to true when animation is active. In some\r\n * cases this leads to an easier implementation for gating on animation state.\r\n *\r\n * @example <caption>With events</caption>\r\n * const flipWithEvents = animateEvents(flip);\r\n * </script>\r\n *\r\n * <main on:animate:start={() => console.log('animate:start')\r\n *       on:animate:end={() => console.log('animate:end')}>\r\n *    {#each someData as entry (entry.id)}\r\n *       <section animate:flipWithEvents />\r\n *    {/each}\r\n\r\n * @example <caption>With optional store</caption>\r\n * const isAnimating = writable(false);\r\n * const flipWithEvents = animateEvents(flip, isAnimating);\r\n * </script>\r\n *\r\n * <main class:no-scroll={$isAnimating}>\r\n *    {#each someData as entry (entry.id)}\r\n *       <section animate:flipWithEvents />\r\n *    {/each}\r\n *\r\n * @param {(node: Element, { from: DOMRect, to: DOMRect }, params?: *) =>\r\n *  import('svelte/animate').AnimationConfig} fn - A Svelte animation function.\r\n *\r\n * @param {import('svelte/store').Writable<boolean>} [store] - An optional boolean writable store that is set to true\r\n *                                                             when animation is active.\r\n *\r\n * @returns {(node: Element, { from: DOMRect, to: DOMRect }, params?: *) =>\r\n *  import('svelte/animate').AnimationConfig} Wrapped animation function.\r\n */\r\nexport function animateEvents(fn, store = void 0)\r\n{\r\n   if (typeof fn !== 'function') { throw new TypeError(`'fn' is not a function.`); }\r\n   if (store !== void 0 && !isWritableStore(store)) { throw new TypeError(`'store' is not a writable store.`); }\r\n\r\n   // Track a single start / end sequence across all animations.\r\n   let startFired = false;\r\n   let endFired = false;\r\n\r\n   return (node, animations, params = {}) =>\r\n   {\r\n      const animationConfig = fn(node, animations, params);\r\n\r\n      // Store any existing tick function.\r\n      const existingTick = animationConfig.tick;\r\n\r\n      // Use tick callback to fire events only once when t / time is 0 and 1.\r\n      animationConfig.tick = (t, u) =>\r\n      {\r\n         // If there is any tick function then invoke it.\r\n         if (existingTick) { existingTick(t, u); }\r\n\r\n         if (!startFired && t === 0)\r\n         {\r\n            if (store) { store.set(true); }\r\n            node.dispatchEvent(new CustomEvent('animate:start', { bubbles: true }));\r\n            startFired = true;\r\n            endFired = false;\r\n         }\r\n\r\n         if (!endFired && t === 1)\r\n         {\r\n            if (store) { store.set(false); }\r\n            node.dispatchEvent(new CustomEvent('animate:end', { bubbles: true }));\r\n            endFired = true;\r\n            startFired = false;\r\n         }\r\n      }\r\n\r\n      return animationConfig;\r\n   }\r\n}\r\n","/**\r\n * Awaits `requestAnimationFrame` calls by the counter specified. This allows asynchronous applications for direct /\r\n * inline style modification amongst other direct animation techniques.\r\n *\r\n * @param {number}   [cntr=1] - A positive integer greater than 0 for amount of requestAnimationFrames to wait.\r\n *\r\n * @returns {Promise<number>} Returns current time equivalent to `performance.now()`.\r\n */\r\nexport async function nextAnimationFrame(cntr = 1)\r\n{\r\n   if (!Number.isInteger(cntr) || cntr < 1)\r\n   {\r\n      throw new TypeError(`nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.`);\r\n   }\r\n\r\n   let currentTime = performance.now();\r\n   for (;--cntr >= 0;)\r\n   {\r\n      currentTime = await new Promise((resolve) => requestAnimationFrame(resolve));\r\n   }\r\n\r\n   return currentTime;\r\n}\r\n"],"names":[],"mappings":"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"}